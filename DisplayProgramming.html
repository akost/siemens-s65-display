<!DOCTYPE html>
<html> <head>



<link type="text/css" rel="stylesheet" href="/static/css/banner-styles.css"/>


<meta charset="UTF-8">
<meta name="robots" content="index,follow">
<link rel="stylesheet" type="text/css" href="superkranz.css">
<meta name="author" content="Christian Kranz">
<title>Display Programming</title></head>
<body>


    <div id="Header">
    </div>

<div id="Content"> </div>
<CENTER>
<H1><img SRC="pics/S65_picture.jpg" ALIGN="left" alt="picture from S65">Programming the S65 Displays</H1>
by <A HREF="DisplayIndex.html">Christian Kranz</A>, October 2005<br>
Updated: December 7, 2005
</CENTER>
<br><br>


<h2> I) LS020 Display </h2>

<H3>Commands and Data</H3>
Data and commands to the display controller are distinguished by the RS line. If RS is high, the controller expects commands, if the RS line is low it expects data. 

<H3>Initialization Commands</H3>

<P>
A LCD TFT display is programmed in three steps. To switch on the display a initialization sequence is needed to program the power chip of the display. That is needed because of the high multiplex rate of the display a relative high voltage is used for driving the glass. The glass voltage can be in the 10V to 20V range and is usually generated by charge pumps.
<br>
After switching on the power usually the display parameter are programmed. In some cases also the boost circuit has to be reprogrammed from startup to active.
<br>
After startup the display can be used for displaying...
</P>

<br>
<p>
The originally measured seven initialization sequences from the S65 display can luckily be reduced to three sequences. In addition we do not need the very long time intervals Siemens used in here approach.

The first (of the three) used initialization sequence is:
</p>

<b>INIT1:</b> Display Software Reset
<BLOCKQUOTE>
<OBJECT>
<PRE>
0xFDFD, 0xFDFD
</PRE>
</OBJECT>
</BLOCKQUOTE>
<p>
It looks like this sequence starts the display controller. After a certain time (min 50ms) the second init command sequence is transmitted to the display.
</p>

<b>INIT2:</b>
<BLOCKQUOTE>
<OBJECT>
<PRE>
0xEF00
0xEE04, 0x1B04
0xFEFE, 0xFEFE
0xEF90, 0x4A04, 0x7F3F, 0xEE04, 0x4306
</PRE>
</OBJECT>
</BLOCKQUOTE>

<p>
After that we need to wait for the display internal voltage settling. This wait time is very sensitive. <b>If the time is too short or too long the display will not work! </b>It was measured to be 7ms and this value shall also be used to drive the display with the sequences shown here.
<br>
The third sequence follows directly and is:
</p>

<b>INIT3:</b>
<BLOCKQUOTE>
<OBJECT>
<PRE>
0xEF90, 0x0983, 0x0800, 0x0BAF, 0x0A00, 0x0500, 0x0600, 0x0700
0xEF00
0xEE0C
0xEF90, 0x0080
0xEFB0, 0x4902
0xEF00
0x7F01, 0xE181
0xE202
0xE276
0xE183
</PRE>
</OBJECT>
</BLOCKQUOTE>

<p>
For a stable initialization we need a break of about 50ms (time might be shortened) before sending the fourth init sequence to the display.
</p>

<b>INIT4:</b>
<BLOCKQUOTE>
<OBJECT>
<PRE>
0x8001
0xEF90, 0x0000
</PRE>
</OBJECT>
</BLOCKQUOTE>


<p>

After this initialization sequence the display is ready to use. An immediate clear screen is recommended because the display shows random content after first power on.
</p>



<H3>Power Down Commands</H3>

<p>
For a regular shutdown a display needs normally a power down sequence to discharge the glass voltage in a controlled manner. Otherwise the lifetime of the display might be reduced. Currently the power down sequence is not known. Therefore we only have the possibility to reset the display and switch off the power supply.
</P>


<H3>Writing Full-Screen and Screen Sections</H3>

<p>
After the initialization the display is ready to use. Usually the first thing to do is to clear the display. That can be perfectly done with the following memory write command.
</p>


<div>
<b>MEMWR:</b>
<BLOCKQUOTE>
<OBJECT>
<PRE>
0xEF90, 0x05OR, 0x06YS, 0x07XS
</PRE>
</OBJECT>
</BLOCKQUOTE>
</div>



<p>
After this command the display data can be written pixel by pixel, each pixel 16-bit. 
</p>
<p>
<img SRC="pics/pixel_write.jpg" ALIGN="right" alt="writing bitmap">
The parameter <b>XS</b> and <b>YS</b> are defining subsections of the display memory. It is not required to write the complete memory. If only a part of the display should be written the data write can be stoppend and the next <b>MEMWR</b> command resets the write pointer to the given coordinates. 
<br><br>
The complete screen is written with <b>XS=0</b> and <b>YS=0</b>. In that case it is not required to repeat the command for each screen write. It is sufficient to write simple the data again and again. The display memory is organized according the picture on the right side. The total number of bytes is 132x176x2, that means in total 0xB580 pixel. The memory is written first in X direction and second in Y-direction. The parameter <b>OR</b> defines the display orientation. <b>OR=0x04</b> sets the 0 degree orientation shown in the figure on the right. <b>OR=0x00</b> defines the 90 degree orientation. For details see the section <a href="#psw">partial screen write</a>. With <b>OR=0x04</b> the memory is written in x-direction, that means line by line in x-direction from left (low x-number) to right (high x-number). With <b>OR=0x00</b> the display memory is written in y-direction, that means from column by column from YS to 131.<br clear="right">
</p>


<H3>Pixel Color Coding</H3>
<p>
The display memory is initialized to work according the -5-6-5- color coding (-R-G-B-) scheme. That means the first (MSB first) 5-bits are coding the intensity of red, the following 6-bits are coding the intensity of green and the last 5-bits the intensity of blue. (0xFFFF is white, 0x0000 is black) 
</p>

<a name="psw"></a>
<H3>Partial Screen Write</H3>
<p>
The display memory is organized in a matrix form with x- and y coordinates. At each matrix coordinate one 16-bit color value (pixel) is stored. (Advanced techniques like PET (sub-pixel addressing) seems not to be supported.) The following picture shows the principle:
</p>

<center>
<p> <b> 0 degree Rotation </b><p>
<br>
  <img SRC="pics/pixel_draw_0.jpg" ALIGN="middle" alt="pixel draw with 0 degree">
<br>
</center>

<p>
For partial writing to the memory the commands below are used. The start corner (X1,Y1) and the end corner (X2,Y2) have to be defined. X2 has to be larger or equal X1, Y2 has to be larger or equal Y1. 
</p>

<div>
<b>PMEMWRX: (X-direction)</b>
<BLOCKQUOTE>
<OBJECT>
<PRE>
0xEF90, 0x0504, 0x08X1, 0x09X2, 0x0AY1, 0x0BY2
</PRE>
</OBJECT>
</BLOCKQUOTE>
</div>

<div>
<b>PMEMWRY: (Y-direction)</b>
<BLOCKQUOTE>
<OBJECT>
<PRE>
0xEF90, 0x0500, 0x08X1, 0x09X2, 0x0AY1, 0x0BY2
</PRE>
</OBJECT>
</BLOCKQUOTE>
</div>

<br>
<p>
For advanced addressing modes of the display controller see <A HREF="DisplayRamAccess.html">advanced addressing modes</A>.
</p>



<h2> II) LPH Display </h2>


<p>
Description of init sequence not ready yet. Please look at the example code.
</p>


<b>Power Down:</b>
<BLOCKQUOTE>
<OBJECT>
<PRE>
0x74 0x00 0x0D
0x76 0x05 0x05
0x74 0x00 0x0E
0x76 0x1D 0x1F
0x74 0x00 0x03
0x76 0x00 0x00
</PRE>
</OBJECT>
</BLOCKQUOTE>





<h2> III) L2F50 Display </h2>


<p>
Description of init sequence not ready yet. Please look at the example code.
</p>

<p>
Currently two different drawing modes are known. The normal mode and 180degree rotated mode. The grafik modes are programmed using the parameter of the <b>DATCTL</b> command.
</p>
<table BORDER="1">
<tr>
<th> DATCTL</th> <th> 7 </th> <th> 6 </th> <th> 5 </th> <th> 4 </th> <th> 3 </th> <th> 2 </th> <th> 1 </th> <th> 0 </th>
</tr>
<tr>
<th> parameter </th> <th>x</th> <th>*</th> <th>1</th> <th>*</th> <th>C2</th> <th>*</th> <th>C1</th> <th>G</th>
</tr>
</table>

<p>
Not all parameter bit combinations are known today. The next table shows the meaning of known bits.
</p>

<table BORDER="1">
<tr> <th> Bit </th> <th> Description </th> </tr>
<tr>
<td> x </td> <td> no influence </td>
</tr>
<tr>
<td> * </td> <td> if set memory not written </td>
</tr>
<tr>
<td> C2 C1 </td> <td>  00: not working </td> </tr>
<tr> <th></th> <td>    01: different color coding </td> </tr>
<tr> <th></th>  <td>   10: not working</td> </tr>
<tr> <th></th> <td>    11: 5-6-5 RGB color coding </td> </tr>
<tr> <td> G </td> <td> 0: normal mode </td> </tr>
<tr> <td> </td> <td> 1: 180 deg. mode </td> </tr>
</table>

<p>
Writing in the different grafik modes is shown in the following figure. In normal mode the (0,0) point is in the left upper corner. The (X,Y) coordinates for the <b>SD_CSET</b> and <b>SD_PSET</b> commands are given in natural order. (X1,Y1) is the upper left corner, (X2,Y2) is the lower right corner. <br>
<br>
In 180 degree mode things are a little bit more confusing. The y-axis changes the direction, but x-axis not. In addition, if a rectangular area is drawn, (X1,Y1) is now the lower right corner of the rectangle and (X2,Y2) is the upper left corner, but still X1 has to be lower than X2 and Y1 has to be lower than Y2. That means if e.g. X1=0 and X2=15 the rectangular is drawn from starting at x=15 with the first bit. Then it is drawn down to x=0 ending with the 16'th bit.

</p>

<center>
<p> <b> Drawing modes Epson L2F50 Display </b><p>
<br>
  <img SRC="pics/pixel_draw_90_L2F50.jpg" ALIGN="middle" alt="pixel draw with 90 degree">
<br>
</center>

<b>Power Down:</b>
<BLOCKQUOTE>
<OBJECT>
<PRE>
0x8E00 - Command
</PRE>
</OBJECT>
</BLOCKQUOTE>







</body>
</html> 




<!--
     FILE ARCHIVED ON 19:42:30 Dec 28, 2008 AND RETRIEVED FROM THE
     INTERNET ARCHIVE ON 20:06:23 Mar 24, 2015.
     JAVASCRIPT APPENDED BY WAYBACK MACHINE, COPYRIGHT INTERNET ARCHIVE.

     ALL OTHER CONTENT MAY ALSO BE PROTECTED BY COPYRIGHT (17 U.S.C.
     SECTION 108(a)(3)).
-->
